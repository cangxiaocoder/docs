---
title: Java
author: 苍晓
date: '2022-11-13'
---
## Java基础

### 静态内部类

1. 为什么这样实现的单例是线程安全的？

   类的加载是线程安全的。

2. 为什么这样实现的单例支持延迟加载？

   静态变量是类加载的时候初始化的，而类是在用到它的时候才会被加载，如：创建对象、创建子类的对象、调用静态方法、调用静态变量使用反射时，这几种情况下，JVM会先将类加载到方法区。其次，外部类加载并不会导致内部类的加载。

3. 为什么SingletonHolder设计为静态内部类，是否可以是普通内部类？

   如果SingletonHolder设计为普通内部类，那么instance将不能是static的，这样instance	无法在类加载的时候加载，那么创建过程就不是线程安全的。

4. 为什么将SingletonHolder设计为private的，而不是public?

   SingletonHolder类只会被Singleton类使用，不会被其他类使用，所以设计成private而不是public。



## JVM结构

<img src="./java_pictures/JVM_Memory.png" alt="JVM內存" style="zoom:80%;"/>

## 类加载器

1. 类加载器接受到类加载的请求
2. 将这请求向上委托个父类加载器，一直向上委托知道启动类加载器
3. 启动类加载器检查释放能够加载当前这个类，能加载就结束，使用当前的加载器，否则抛出异常，通知子加载器加载

## Native 方法区

#### Native Method Stack

> 它的具体做法是NativeMethodStack 中登记native方法，在执行引擎（Execution Engine）执行的时候加载NativeLibraies(本地库)

- 凡是带native关键字的，说明Java作用范围达不到，会去调用底层C/C++语言的库
- 会进入本地方法栈，调用本地方法本地接口JIN
- JINO作用：扩展Java的使用，融合不同的编程语言为Java所用

## PC寄存器

程序计数器 Program Counter Register

每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址，即即将要执行的代码指令），在执行引擎读取下一条指令，是一个非常小的内存空间

## 方法区

Method Area方法区

方法去被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义。所有定义方法的信息不都保存在这个区域，**此区域属于共享空间**。

==静态变量、常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是实例变量存在堆中，和方法区无关==

关键词：static final Class 常量池

## 栈

栈内存主管程序运行，生命周期和线程同步，线程结束，栈内存也就释放，对于栈来说不存在垃圾回收

栈：八大基本数据类型+对象引用+实例方法

<img src="./java_pictures/stack.png" alt="image-20220828162459609" style="zoom:80%;"/>

## 栈、堆、方法区交互

![image-20220830221316984](./java_pictures/image-20220830221316984.png)





