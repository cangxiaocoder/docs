(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{401:function(a,v,_){a.exports=_.p+"assets/img/image-20230610140717369.413de928.png"},402:function(a,v,_){a.exports=_.p+"assets/img/image-20230610223424536.0f26f623.png"},403:function(a,v,_){a.exports=_.p+"assets/img/image-20230611105805843.7896ffad.png"},432:function(a,v,_){"use strict";_.r(v);var l=_(4),r=Object(l.a)({},(function(){var a=this,v=a._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h3",{attrs:{id:"kafka如何保证消息不丢失"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#kafka如何保证消息不丢失"}},[a._v("#")]),a._v(" kafka如何保证消息不丢失")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("生产者发送消息到Broker丢失")]),a._v(" "),v("ul",[v("li",[a._v("设置异步发送消息")]),a._v(" "),v("li",[a._v("如果出现异常则重试")])])]),a._v(" "),v("li",[v("p",[a._v("消息在Broker中存储丢失")]),a._v(" "),v("ul",[v("li",[a._v("发送确认机制acks\n"),v("ul",[v("li",[a._v("0：生产者发送过来的数据，不需要等待数据落盘就应答；消息有丢失风险，但是速度快")]),a._v(" "),v("li",[a._v("1：生产者发送过来的数据，Leader收到数据后应答；能保证leader保存 一份数据")]),a._v(" "),v("li",[a._v("-1(all)：生产者发送过来的数据，Leader和isr队列里面的所有节点收齐数据后应答。-1和all等价")])])])])]),a._v(" "),v("li",[v("p",[a._v("消费者从Broker消费消息丢失")]),a._v(" "),v("p",[a._v("丢失问题：消费者默认是按期自动提交消费偏移量，默认是每5秒提交一次，如果出现重平衡可能会出现重复消费数据或丢失数据")]),a._v(" "),v("ul",[v("li",[a._v("禁用自动提交，改为手动提交")]),a._v(" "),v("li",[a._v("提交方式：同步+异步组合提交")])])])]),a._v(" "),v("h3",{attrs:{id:"重平衡"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重平衡"}},[a._v("#")]),a._v(" 重平衡")]),a._v(" "),v("blockquote",[v("p",[a._v("重平衡发送情况：")]),a._v(" "),v("p",[a._v("分区个数增加")]),a._v(" "),v("p",[a._v("对topic订阅发生变化")]),a._v(" "),v("p",[a._v("消费者组成员增加或者离开，消费者组中有消费者宕机或者增加消费者")])]),a._v(" "),v("p",[v("img",{attrs:{src:_(401),alt:"image-20230610140717369"}})]),a._v(" "),v("ol",[v("li",[a._v("如果消费者2消费消息偏移量为5，但是只提交偏移量到3宕机，偏移量4、5的消息就会被重复消费，")]),a._v(" "),v("li",[a._v("如果消费者2消费到3并且提交了偏移量，但是消费者2宕机了，消费者2消费的消息就会丢失")])]),a._v(" "),v("h3",{attrs:{id:"kafka如何保证消费的顺序性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#kafka如何保证消费的顺序性"}},[a._v("#")]),a._v(" kafka如何保证消费的顺序性")]),a._v(" "),v("p",[a._v("topic的每个分区只能有消费者组中的一个消费者消费。所以kafka只能保证单分区消息消费有序，如果需要消息消费有序则需要将所有的消息都放在相同的分区")]),a._v(" "),v("ul",[v("li",[a._v("发送消息时指定分区号")]),a._v(" "),v("li",[a._v("发送消息时按照相同的业务设置相同的key")])]),a._v(" "),v("h3",{attrs:{id:"kafka高可用机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#kafka高可用机制"}},[a._v("#")]),a._v(" kafka高可用机制")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("集群模式")]),a._v(" "),v("ul",[v("li",[a._v("kafka服务端由Broker的服务进程构成，一个kafka集群有多个broker组成")]),a._v(" "),v("li",[a._v("当集群上某一台服务器宕机了，其他机器上的Broker也能对外提供服务")])])]),a._v(" "),v("li",[v("p",[a._v("分区备份机制")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("一个topic有多个分区，每个分区有多个副本，其中一个是leader，其它的为follower，副本存在不同的Broker中")])]),a._v(" "),v("li",[v("p",[a._v("所有的分区副本内容都是相同的，如果leader发生了故障，会自动将其中一个follower提升为leader")]),a._v(" "),v("ul",[v("li",[a._v("ISR副本，需要同步复制的副本，如果leader失效需要选出新的leader")]),a._v(" "),v("li",[a._v("优先选举ISR副本中选择leader，因为ISR副本中的数据是与leader最接近的")]),a._v(" "),v("li",[a._v("如果ISR副本的follower都不可用，则在普通副本中选取")])]),a._v(" "),v("p",[v("img",{attrs:{src:_(402),alt:"image-20230610223424536"}})])])])])]),a._v(" "),v("h3",{attrs:{id:"kafka中的高性能设计"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#kafka中的高性能设计"}},[a._v("#")]),a._v(" kafka中的高性能设计")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("消息分区：不受单台服务器的限制，可以不受限的处理更多的数据")])]),a._v(" "),v("li",[v("p",[a._v("顺序读写：磁盘顺序读写，提升读写效率")])]),a._v(" "),v("li",[v("p",[a._v("页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问")])]),a._v(" "),v("li",[v("p",[a._v("零拷贝：减少上下文切换以及数据拷贝")]),a._v(" "),v("p",[v("img",{attrs:{src:_(403),alt:"image-20230611105805843"}})])]),a._v(" "),v("li",[v("p",[a._v("消息压缩：减少磁盘IO和网络IO")])]),a._v(" "),v("li",[v("p",[a._v("分批发送：将消息打包批量发送，减少网络开销")])])])])}),[],!1,null,null,null);v.default=r.exports}}]);