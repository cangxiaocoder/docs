(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{332:function(t,e,a){t.exports=a.p+"assets/img/image-20211030163050167.629b62eb.png"},333:function(t,e,a){t.exports=a.p+"assets/img/image-20211030170413951.07dc38f0.png"},334:function(t,e,a){t.exports=a.p+"assets/img/image-20211030174703160.094d4440.png"},335:function(t,e,a){t.exports=a.p+"assets/img/image-20211030180629348.088d02b6.png"},380:function(t,e,a){"use strict";a.r(e);var v=a(7),_=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"mysql事务原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql事务原理"}},[t._v("#")]),t._v(" MySQL事务原理")]),t._v(" "),e("p",[t._v("MySQL底层到底是如何实现事务的呢？ 其实使用了==MVCC多版本控制机制，事务隔离机制，锁机制==等来解决事务并发问题。如果数据库事务在并发过程中不做控制和处理，会产生那些影响呢？")]),t._v(" "),e("h3",{attrs:{id:"脏数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#脏数据"}},[t._v("#")]),t._v(" 脏数据")]),t._v(" "),e("blockquote",[e("p",[t._v("脏数据一般可以分为四种：脏写，脏读，不可重复读，幻读")])]),t._v(" "),e("h4",{attrs:{id:"脏写"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#脏写"}},[t._v("#")]),t._v(" 脏写")]),t._v(" "),e("blockquote",[e("p",[t._v("脏写是指一个事务修改并且提交的数据被另外一个事务回滚了")])]),t._v(" "),e("p",[t._v("分析：假设有两个事务 A、B，事务 A 先开启事务，修改了数据库 id 为1 的记录，如将 name 改成了 ’李四‘，此时事务 A 还没有提交，这个时候事务B开启了，事务 B 将 id 为 1 的记录修改为 ‘王五’，并且事务 B 先与事务 A 提交事务。但是这个时候事务 A 不想修改了，或者在事务 A 内出现了异常，将自己修改的事务回滚了，此时 id 为1 的这条记录的 name 的值还是 ‘张三’；这就是脏写， 事务B已经写入的记录被事务 A 回滚掉了；")]),t._v(" "),e("p",[e("img",{attrs:{src:a(332),alt:"image-20211030163050167"}})]),t._v(" "),e("p",[t._v("那 MySQL 是如何解决脏写的问题呢？ 猜对了，就是"),e("strong",[t._v("锁")]),t._v("。在MySQL事务中对于涉及到的行会按照需要加锁，但是执行完并不会立马释放锁，只有当前事务提交的时候才会释放锁，所以当事务 A 要修改这条记录的之前，它会持有这条记录的写锁，而写锁是一种互斥锁，这时事务 B 开启想去修改 id = 1 的这条记录时也需要持有这条记录的锁，但由于事务 A 还没有提交，事务只能等待，当事务 A 执行完成，事务 B 才会开始执行。")]),t._v(" "),e("h4",{attrs:{id:"脏读"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#脏读"}},[t._v("#")]),t._v(" 脏读")]),t._v(" "),e("blockquote",[e("p",[t._v("脏读是指一个事务读取到了另外一个事务还没有提交的数据")])]),t._v(" "),e("p",[t._v("分析：还是假设有两个事务 A 、B。事务 A先开启了，并将 id = 1 的记录name 修改成了 ‘李四’，但是事务 A 还没有提交，此时事务 B 开启了，事务 B 查询这条  id = 1的这条记录，查询到name的值为‘李四’，然后按照这个值去执行其他业务操作，如果此时事务 A 回滚了之前的修改，那么事务 B 再次查询id= 1的记录发现name的值并不是‘李四’，这就是脏读。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(333),alt:"image-20211030170413951"}})]),t._v(" "),e("h4",{attrs:{id:"不可重复读"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不可重复读"}},[t._v("#")]),t._v(" 不可重复读")]),t._v(" "),e("blockquote",[e("p",[t._v("不可重复读是指前后读取同一条记录结果不一样")])]),t._v(" "),e("p",[t._v("分析： 假设有两个事务A、B。事务 A 先开启查询了 id=1 的记录name的值是‘张三’，还没有执行任何操作，此时事务B开启了，修改了 id=1的记录，将name改为‘李四’，此时事务 A 再次查询这条记录，发现name的值变成了’李四‘，这就是不可重复读，前后读取同一条记录结果不一样。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(334),alt:"image-20211030174703160"}})]),t._v(" "),e("h4",{attrs:{id:"幻读"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#幻读"}},[t._v("#")]),t._v(" 幻读")]),t._v(" "),e("blockquote",[e("p",[t._v("幻读是指前后读取到的记录的数量不一样")])]),t._v(" "),e("p",[t._v("分析：幻读和不可重复读有点类似，不可重复读强调的是数据值不一样，重点是修改；而幻读强调的是记录的数量不一样，重点是新增和删除。")]),t._v(" "),e("p",[t._v("假设有两个事务A 、B，事务 A 先开启，并执行了SQL："),e("code",[t._v("select * from student")]),t._v("，总共有3条记录，此时我事务 B 开启了，并想student表插入了一条记录，并提交了事务，此时事务 A 再次执行SQL："),e("code",[t._v("select * from student")]),t._v(", 结果发现有4条记录，这就是幻读。这些问题会在不同的数据库的事务隔离级别下产生。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(335),alt:"image-20211030180629348"}})]),t._v(" "),e("h3",{attrs:{id:"事务基本特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事务基本特性"}},[t._v("#")]),t._v(" 事务基本特性")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("原子性（Atomicity）")]),t._v("：一个事务中的所有操作，要么全部完成，要么全部不完成，若事务执行出错，会被回滚到事务开始前的状态。")]),t._v(" "),e("li",[e("strong",[t._v("一致性（Consistency）")]),t._v("：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。")]),t._v(" "),e("li",[e("strong",[t._v("隔离性（Isolation）")]),t._v("：数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止多个事务并发执行时导致数据的不一致的情况。")]),t._v(" "),e("li",[e("strong",[t._v("持久性（Durability）")]),t._v("：事务提交后，对数据的修改就是永久的。")])]),t._v(" "),e("p",[t._v("InnoDB 引擎通过以下方法来保证事务的这四个特性：")]),t._v(" "),e("ul",[e("li",[t._v("redo log （重做日志）保证持久性；")]),t._v(" "),e("li",[t._v("undo log（回滚日志） 保证原子性；")]),t._v(" "),e("li",[t._v("MVCC（多版本并发控制） 和锁机制来保证隔离性；")]),t._v(" "),e("li",[t._v("持久性+原子性+隔离性保证一致性；")])]),t._v(" "),e("h3",{attrs:{id:"事务隔离级别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离级别"}},[t._v("#")]),t._v(" 事务隔离级别")]),t._v(" "),e("p",[t._v("事务的隔离级别有四种")]),t._v(" "),e("ol",[e("li",[t._v("Read uncommitted：读未提交，表示一个事务可以读取到另外一个事务未提交的修改；")]),t._v(" "),e("li",[t._v("Read Committed(RC)：读已提交，表示一个事务只能读到另外一个事务已经提交的修改；")]),t._v(" "),e("li",[t._v("Repeatable Read(RR)：可重复读，MySQL的默认隔离级别，表示只要事务还在进行中，彼此之间互不影响；")]),t._v(" "),e("li",[t._v("Serializable：串行化，表示所有的事务只能一个一个来，效率最低。")])]),t._v(" "),e("p",[t._v("不同的隔离级别可能出现的问题")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("隔离级别")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("脏写")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("脏读")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("不可重复读")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("幻读")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("Read uncommitted：读未提交")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("✘")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("✔")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("✔")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("✔")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("Read Committed(RC)：读已提交")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("✘")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("✘")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("✔")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("✔")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("Repeatable Read(RR)：可重复读")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("✘")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("✘")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("✘")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("✔")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("serializable：串行化")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("✘")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("✘")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("✘")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("✘")])])])]),t._v(" "),e("p",[t._v("在 MySQL 有两种开启事务的命令：")]),t._v(" "),e("ul",[e("li",[t._v("第一种：begin/start transaction 命令；")]),t._v(" "),e("li",[t._v("第二种：start transaction with consistent snapshot 命令；")])]),t._v(" "),e("p",[t._v("这两种开启事务的命令，事务的启动时机是不同的：")]),t._v(" "),e("ul",[e("li",[t._v("执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；")]),t._v(" "),e("li",[t._v("执行了 start transaction with consistent snapshot 命令，就会马上启动事务。")])]),t._v(" "),e("h3",{attrs:{id:"场景再现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#场景再现"}},[t._v("#")]),t._v(" 场景再现")]),t._v(" "),e("ol",[e("li",[t._v("在一个事务A中删除统计数据记录")]),t._v(" "),e("li",[t._v("去其他窗口查询统计数据")]),t._v(" "),e("li",[t._v("开启事务B批量插入数据并立即提交")]),t._v(" "),e("li",[t._v("由于插入的数据和第一个事务中删除的数据在逻辑上是同一条数据，所以程序被卡在")])]),t._v(" "),e("p",[t._v("分析：oracle 的默认隔离级别是读已提交，那么在事务A中，删除的数据还没有提交对事务B是不可见的，那事务B去插入数据时发现这条数据没有被删除，不是应该会报唯一键冲突吗，为什么会出现程序被卡主，事务长时间未提交？")]),t._v(" "),e("p",[t._v("事实上，当事务A删除这条记录的时候会绑定这条记录，拥有这条记录写锁，虽然删除语句已经执行完成，但是这把锁并没有被释放，只有当事务A提交时才会释放行锁，此时B要在这一行插入一条记录，那么也需要先获得这条记录的行锁，而写锁是一种互斥锁，只有当事务A释放锁后事务B才能拿到锁，而事务B嵌套在事务A中，会互相等待释放资源，从而出现了死锁，死锁一般只有等待执行超时，在MySQL中有个死锁检测，在orcale中不知道有没有，好像没有查到，其实不仅是删除和插入会遇到这种死锁问题，包括update也会出现死锁；如果使用for update锁查也会出现死锁，")]),t._v(" "),e("p",[t._v("总结：当出现嵌套事务的时候应该考虑是否会产生事务冲突；")])])}),[],!1,null,null,null);e.default=_.exports}}]);