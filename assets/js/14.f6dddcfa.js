(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{430:function(t,a,v){t.exports=v.p+"assets/img/JVM_Memory.f33446af.png"},431:function(t,a,v){t.exports=v.p+"assets/img/stack.b5503736.png"},432:function(t,a,v){t.exports=v.p+"assets/img/image-20220830221316984.7f1cedbf.png"},461:function(t,a,v){"use strict";v.r(a);var s=v(2),e=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"java基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java基础"}},[t._v("#")]),t._v(" Java基础")]),t._v(" "),a("h3",{attrs:{id:"静态内部类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#静态内部类"}},[t._v("#")]),t._v(" 静态内部类")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("为什么这样实现的单例是线程安全的？")]),t._v(" "),a("p",[t._v("类的加载是线程安全的。")])]),t._v(" "),a("li",[a("p",[t._v("为什么这样实现的单例支持延迟加载？")]),t._v(" "),a("p",[t._v("静态变量是类加载的时候初始化的，而类是在用到它的时候才会被加载，如：创建对象、创建子类的对象、调用静态方法、调用静态变量使用反射时，这几种情况下，JVM会先将类加载到方法区。其次，外部类加载并不会导致内部类的加载。")])]),t._v(" "),a("li",[a("p",[t._v("为什么SingletonHolder设计为静态内部类，是否可以是普通内部类？")]),t._v(" "),a("p",[t._v("如果SingletonHolder设计为普通内部类，那么instance将不能是static的，这样instance\t无法在类加载的时候加载，那么创建过程就不是线程安全的。")])]),t._v(" "),a("li",[a("p",[t._v("为什么将SingletonHolder设计为private的，而不是public?")]),t._v(" "),a("p",[t._v("SingletonHolder类只会被Singleton类使用，不会被其他类使用，所以设计成private而不是public。")])])]),t._v(" "),a("h2",{attrs:{id:"jvm结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm结构"}},[t._v("#")]),t._v(" JVM结构")]),t._v(" "),a("img",{staticStyle:{zoom:"80%"},attrs:{src:v(430),alt:"JVM內存"}}),t._v(" "),a("h2",{attrs:{id:"类加载器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[t._v("#")]),t._v(" 类加载器")]),t._v(" "),a("ol",[a("li",[t._v("类加载器接受到类加载的请求")]),t._v(" "),a("li",[t._v("将这请求向上委托个父类加载器，一直向上委托知道启动类加载器")]),t._v(" "),a("li",[t._v("启动类加载器检查释放能够加载当前这个类，能加载就结束，使用当前的加载器，否则抛出异常，通知子加载器加载")])]),t._v(" "),a("h2",{attrs:{id:"native-方法区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#native-方法区"}},[t._v("#")]),t._v(" Native 方法区")]),t._v(" "),a("h4",{attrs:{id:"native-method-stack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#native-method-stack"}},[t._v("#")]),t._v(" Native Method Stack")]),t._v(" "),a("blockquote",[a("p",[t._v("它的具体做法是NativeMethodStack 中登记native方法，在执行引擎（Execution Engine）执行的时候加载NativeLibraies(本地库)")])]),t._v(" "),a("ul",[a("li",[t._v("凡是带native关键字的，说明Java作用范围达不到，会去调用底层C/C++语言的库")]),t._v(" "),a("li",[t._v("会进入本地方法栈，调用本地方法本地接口JIN")]),t._v(" "),a("li",[t._v("JINO作用：扩展Java的使用，融合不同的编程语言为Java所用")])]),t._v(" "),a("h2",{attrs:{id:"pc寄存器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pc寄存器"}},[t._v("#")]),t._v(" PC寄存器")]),t._v(" "),a("p",[t._v("程序计数器 Program Counter Register")]),t._v(" "),a("p",[t._v("每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址，即即将要执行的代码指令），在执行引擎读取下一条指令，是一个非常小的内存空间")]),t._v(" "),a("h2",{attrs:{id:"方法区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[t._v("#")]),t._v(" 方法区")]),t._v(" "),a("p",[t._v("Method Area方法区")]),t._v(" "),a("p",[t._v("方法去被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义。所有定义方法的信息不都保存在这个区域，"),a("strong",[t._v("此区域属于共享空间")]),t._v("。")]),t._v(" "),a("p",[t._v("==静态变量、常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是实例变量存在堆中，和方法区无关==")]),t._v(" "),a("p",[t._v("关键词：static final Class 常量池")]),t._v(" "),a("h2",{attrs:{id:"栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),a("p",[t._v("栈内存主管程序运行，生命周期和线程同步，线程结束，栈内存也就释放，对于栈来说不存在垃圾回收")]),t._v(" "),a("p",[t._v("栈：八大基本数据类型+对象引用+实例方法")]),t._v(" "),a("img",{staticStyle:{zoom:"80%"},attrs:{src:v(431),alt:"image-20220828162459609"}}),t._v(" "),a("h2",{attrs:{id:"栈、堆、方法区交互"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈、堆、方法区交互"}},[t._v("#")]),t._v(" 栈、堆、方法区交互")]),t._v(" "),a("p",[a("img",{attrs:{src:v(432),alt:"image-20220830221316984"}})])])}),[],!1,null,null,null);a.default=e.exports}}]);