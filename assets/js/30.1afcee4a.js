(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{442:function(s,a,e){s.exports=e.p+"assets/img/image-20231103223316674.4673a304.png"},443:function(s,a,e){s.exports=e.p+"assets/img/image-20231103224149659.3276f3fc.png"},444:function(s,a,e){s.exports=e.p+"assets/img/image-20231103224647416.0b3d6d4f.png"},485:function(s,a,e){"use strict";e.r(a);var t=e(4),n=Object(t.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"rdb持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb持久化"}},[s._v("#")]),s._v(" RDB持久化")]),s._v(" "),a("h3",{attrs:{id:"redis数据备份"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis数据备份"}},[s._v("#")]),s._v(" Redis数据备份")]),s._v(" "),a("p",[s._v("RDB(Redis Database Backup file),Redis数据备份文件，也称为Redis数据快照，它会将内存中所有的数据都记录在磁盘中，当Redis宕机重启后，从磁盘中读取快照文件恢复数据。")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 由Redis主进程来执行RDB，会阻塞所有命令")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:637"),a("span",{pre:!0,attrs:{class:"token operator"}},[a("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("9")]),s._v(">")]),s._v(" save\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 开启子进程执行RDB，不会阻塞主进程")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:637"),a("span",{pre:!0,attrs:{class:"token operator"}},[a("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("9")]),s._v(">")]),s._v("bgsave\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("# 配置多少秒内有多少个key被修改则执行bgsave命令\nsave <seconds> <changes>\nsave 900 1\nsave 300 10\nsave 60 1000\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("h3",{attrs:{id:"rdb执行原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb执行原理"}},[s._v("#")]),s._v(" RDB执行原理")]),s._v(" "),a("p",[s._v("bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RDB文件")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("主进程和子进程具有相同的页表，相同的页表会映射相同的物理内存")])]),s._v(" "),a("li",[a("p",[s._v("fork采用的是copy-on-write技术，")]),s._v(" "),a("ul",[a("li",[s._v("当主进程执行读操作时，访问共享内存")]),s._v(" "),a("li",[s._v("当主进程执行写操作时，则会先拷贝一份数据，然后执行写操作。")])]),s._v(" "),a("p",[a("img",{attrs:{src:e(442),alt:"image-20231103223316674"}})])])]),s._v(" "),a("h2",{attrs:{id:"aof持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof持久化"}},[s._v("#")]),s._v(" AOF持久化")]),s._v(" "),a("h3",{attrs:{id:"aof配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof配置"}},[s._v("#")]),s._v(" AOF配置")]),s._v(" "),a("p",[s._v("AOF默认是关闭的，需要修改Redis.conf配置文件来开启AOF;")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('# 是否开启AOF功能。默认为no\nappendonly yes\n# AOF文件名称\nappendfilename "appendonly.aof"\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("AOF的命令记录评率也可以通过redis.conf文件来陪")]),s._v(" "),a("ul",[a("li",[s._v("always：表示每写一次命令就立即记录到AOF文件中")]),s._v(" "),a("li",[s._v("everysec：写完命令会先记录到AOF缓冲区，然后每隔1秒将缓冲区的文件写到AOF文件中，默认方案")]),s._v(" "),a("li",[s._v("no：写完命令会先记录到AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('# More details please check the following article:\n# http://antirez.com/post/redis-persistence-demystified.html\n#\n# If unsure, use "everysec".\n\n# appendfsync always\nappendfsync everysec\n# appendfsync no\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[a("img",{attrs:{src:e(443),alt:"image-20231103224149659"}})]),s._v(" "),a("h3",{attrs:{id:"aof重写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof重写"}},[s._v("#")]),s._v(" AOF重写")]),s._v(" "),a("p",[s._v("因为AOF是记录命令，所以AOF文件会比RDB文件大的多，而且AOF文件会记录对同一个key的多次写操作，但只有最后一次写操作才有意义，通过执行"),a("code",[s._v("bgrewriteaof")]),s._v("命令，可以让AOF文件执行重写功能。")]),s._v(" "),a("p",[a("img",{attrs:{src:e(444),alt:"image-20231103224647416"}})]),s._v(" "),a("h4",{attrs:{id:"配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置"}},[s._v("#")]),s._v(" 配置")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("# Specify a percentage of zero in order to disable the automatic AOF\n# rewrite feature.\n# AOF文件比上次文件增长超过多少百分比则触发重写\nauto-aof-rewrite-percentage 100\n# AOF文件体积最小多大以上才触发重写\nauto-aof-rewrite-min-size 64mb\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h2",{attrs:{id:"混合持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#混合持久化"}},[s._v("#")]),s._v(" 混合持久化")]),s._v(" "),a("h3",{attrs:{id:"配置-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置-2"}},[s._v("#")]),s._v(" 配置")]),s._v(" "),a("p",[s._v("实际开发中需要将两者都开启，开启混合持久化功能")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("# Redis can create append-only base files in either RDB or AOF formats. Using\n# the RDB format is always faster and more efficient, and disabling it is only\n# supported for backward compatibility purposes.\naof-use-rdb-preamble yes\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("当开启了混合持久化时，在 AOF 重写日志时，"),a("code",[s._v("fork")]),s._v(" 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。")]),s._v(" "),a("p",[s._v("也就是说，使用了混合持久化，AOF 文件的"),a("strong",[s._v("前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据")]),s._v("。")]),s._v(" "),a("p",[s._v("这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样"),a("strong",[s._v("加载的时候速度会很快")]),s._v("。")]),s._v(" "),a("p",[s._v("加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得"),a("strong",[s._v("数据更少的丢失")]),s._v("。")])])}),[],!1,null,null,null);a.default=n.exports}}]);